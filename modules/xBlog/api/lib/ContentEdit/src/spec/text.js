// Generated by CoffeeScript 1.10.0
describe('`ContentEdit.Text()`', function() {
  return it('should return an instance of Text`', function() {
    var text;
    text = new ContentEdit.Text('p', {}, 'foo <b>bar</b>');
    return expect(text instanceof ContentEdit.Text).toBe(true);
  });
});

describe('`ContentEdit.Text.cssTypeName()`', function() {
  return it('should return \'text\'', function() {
    var text;
    text = new ContentEdit.Text('p', {}, 'foo');
    return expect(text.cssTypeName()).toBe('text');
  });
});

describe('`ContentEdit.Text.type()`', function() {
  return it('should return \'Text\'', function() {
    var text;
    text = new ContentEdit.Text('p', {}, 'foo <b>bar</b>');
    return expect(text.type()).toBe('Text');
  });
});

describe('`ContentEdit.Text.typeName()`', function() {
  return it('should return \'Text\'', function() {
    var text;
    text = new ContentEdit.Text('p', {}, 'foo <b>bar</b>');
    return expect(text.typeName()).toBe('Text');
  });
});

describe('ContentEdit.Text.blur()', function() {
  var region, root, text;
  root = ContentEdit.Root.get();
  text = null;
  region = null;
  beforeEach(function() {
    text = new ContentEdit.Text('p', {}, 'foo');
    region = new ContentEdit.Region(document.getElementById('test'));
    region.attach(text);
    return text.focus();
  });
  afterEach(function() {
    return region.detach(text);
  });
  it('should blur the text element', function() {
    text.blur();
    return expect(text.isFocused()).toBe(false);
  });
  it('should remove the text element if it\'s just whitespace', function() {
    text.domElement().innerHTML = '';
    text.content = new HTMLString.String('');
    text.blur();
    return expect(text.parent()).toBe(null);
  });
  return it('should trigger the `blur` event against the root', function() {
    var foo;
    foo = {
      handleFoo: function() {}
    };
    spyOn(foo, 'handleFoo');
    root.bind('blur', foo.handleFoo);
    text.blur();
    return expect(foo.handleFoo).toHaveBeenCalledWith(text);
  });
});

describe('`ContentEdit.Text.createDraggingDOMElement()`', function() {
  return it('should create a helper DOM element', function() {
    var helper, region, text;
    text = new ContentEdit.Text('p', {}, 'foo <b>bar</b>');
    region = new ContentEdit.Region(document.createElement('div'));
    region.attach(text);
    helper = text.createDraggingDOMElement();
    expect(helper).not.toBe(null);
    expect(helper.tagName.toLowerCase()).toBe('div');
    return expect(helper.innerHTML).toBe('foo bar');
  });
});

describe('ContentEdit.Text.drag()', function() {
  var root, text;
  root = ContentEdit.Root.get();
  text = null;
  beforeEach(function() {
    var region;
    text = new ContentEdit.Text('p', {}, 'foo');
    region = new ContentEdit.Region(document.createElement('div'));
    return region.attach(text);
  });
  afterEach(function() {
    return root.cancelDragging();
  });
  it('should call `storeState` against the text element', function() {
    spyOn(text, 'storeState');
    text.drag(0, 0);
    return expect(text.storeState).toHaveBeenCalled();
  });
  return it('should call `startDragging` against the root element', function() {
    spyOn(root, 'startDragging');
    text.drag(0, 0);
    return expect(root.startDragging).toHaveBeenCalledWith(text, 0, 0);
  });
});

describe('ContentEdit.Text.drop()', function() {
  return it('should call the `restoreState` against the text element', function() {
    var region, textA, textB;
    textA = new ContentEdit.Text('p', {}, 'foo');
    textB = new ContentEdit.Text('p', {}, 'bar');
    region = new ContentEdit.Region(document.createElement('div'));
    region.attach(textA);
    region.attach(textB);
    spyOn(textA, 'restoreState');
    textA.storeState();
    textA.drop(textB, ['above', 'center']);
    return expect(textA.restoreState).toHaveBeenCalled();
  });
});

describe('ContentEdit.Text.focus()', function() {
  var region, root, text;
  root = ContentEdit.Root.get();
  text = null;
  region = null;
  beforeEach(function() {
    text = new ContentEdit.Text('p', {}, 'foo');
    region = new ContentEdit.Region(document.getElementById('test'));
    region.attach(text);
    return text.blur();
  });
  afterEach(function() {
    return region.detach(text);
  });
  it('should focus the text element', function() {
    text.focus();
    return expect(text.isFocused()).toBe(true);
  });
  return it('should trigger the `focus` event against the root', function() {
    var foo;
    foo = {
      handleFoo: function() {}
    };
    spyOn(foo, 'handleFoo');
    root.bind('focus', foo.handleFoo);
    text.focus();
    return expect(foo.handleFoo).toHaveBeenCalledWith(text);
  });
});

describe('ContentEdit.Text.html()', function() {
  return it('should return a HTML string for the text element', function() {
    var text;
    text = new ContentEdit.Text('p', {
      'class': 'foo'
    }, 'bar <b>zee</b>');
    return expect(text.html()).toBe('<p class="foo">\n' + (ContentEdit.INDENT + "bar <b>zee</b>\n") + '</p>');
  });
});

describe('ContentEdit.Text.mount()', function() {
  var region, text;
  text = null;
  region = null;
  beforeEach(function() {
    text = new ContentEdit.Text('p', {}, 'foo');
    region = new ContentEdit.Region(document.createElement('div'));
    region.attach(text);
    return text.unmount();
  });
  it('should mount the text element to the DOM', function() {
    text.mount();
    return expect(text.isMounted()).toBe(true);
  });
  it('should call `updateInnerHTML` against the text element', function() {
    spyOn(text, 'updateInnerHTML');
    text.mount();
    return expect(text.updateInnerHTML).toHaveBeenCalled();
  });
  return it('should trigger the `mount` event against the root', function() {
    var foo, root;
    foo = {
      handleFoo: function() {}
    };
    spyOn(foo, 'handleFoo');
    root = ContentEdit.Root.get();
    root.bind('mount', foo.handleFoo);
    text.mount();
    return expect(foo.handleFoo).toHaveBeenCalledWith(text);
  });
});

describe('ContentEdit.Text.restoreState()', function() {
  return it('should restore a text elements state after it has been remounted', function() {
    var region, selection, text;
    text = new ContentEdit.Text('p', {}, 'foo');
    region = new ContentEdit.Region(document.getElementById('test'));
    region.attach(text);
    text.focus();
    new ContentSelect.Range(1, 2).select(text.domElement());
    text.storeState();
    text.unmount();
    text.mount();
    text.restoreState();
    selection = ContentSelect.Range.query(text.domElement());
    expect(selection.get()).toEqual([1, 2]);
    return region.detach(text);
  });
});

describe('ContentEdit.Text.selection()', function() {
  return it('should get/set the content selection for the element', function() {
    var region, text;
    text = new ContentEdit.Text('p', {}, 'foobar');
    region = new ContentEdit.Region(document.getElementById('test'));
    region.attach(text);
    text.selection(new ContentSelect.Range(1, 2));
    expect(text.selection().get()).toEqual([1, 2]);
    return region.detach(text);
  });
});

describe('ContentEdit.Text.storeState()', function() {
  return it('should store the text elements state so it can be restored', function() {
    var region, selection, text;
    text = new ContentEdit.Text('p', {}, 'foo');
    region = new ContentEdit.Region(document.getElementById('test'));
    region.attach(text);
    text.focus();
    new ContentSelect.Range(1, 2).select(text.domElement());
    text.storeState();
    expect(text._savedSelection.get()).toEqual([1, 2]);
    text.unmount();
    text.mount();
    text.restoreState();
    selection = ContentSelect.Range.query(text.domElement());
    expect(selection.get()).toEqual([1, 2]);
    return region.detach(text);
  });
});

describe('ContentEdit.Text.updateInnerHTML()', function() {
  return it('should update the contents of the text elements related DOM element', function() {
    var region, text;
    text = new ContentEdit.Text('p', {}, 'foo');
    region = new ContentEdit.Region(document.getElementById('test'));
    region.attach(text);
    text.content = text.content.concat(' bar');
    text.updateInnerHTML();
    expect(text.domElement().innerHTML).toBe('foo bar');
    return region.detach(text);
  });
});

describe('`ContentEdit.Text.fromDOMElement()`', function() {
  return it('should convert the following DOM elements into a text element: <address>, <h1>, <h2>, <h3>, <h4>, <h5>, <h6>, <p>', function() {
    var INDENT, address, domAddress, domH, domP, h, i, j, p;
    INDENT = ContentEdit.INDENT;
    domAddress = document.createElement('address');
    domAddress.innerHTML = 'foo';
    address = ContentEdit.Text.fromDOMElement(domAddress);
    expect(address.html()).toBe("<address>\n" + INDENT + "foo\n</address>");
    for (i = j = 1; j < 7; i = ++j) {
      domH = document.createElement("h" + i);
      domH.innerHTML = 'foo';
      h = ContentEdit.Text.fromDOMElement(domH);
      expect(h.html()).toBe("<h" + i + ">\n" + INDENT + "foo\n</h" + i + ">");
    }
    domP = document.createElement('p');
    domP.innerHTML = 'foo';
    p = ContentEdit.Text.fromDOMElement(domP);
    return expect(p.html()).toBe("<p>\n" + INDENT + "foo\n</p>");
  });
});

describe('`ContentEdit.Text` key events`', function() {
  var INDENT, ev, region, root;
  INDENT = ContentEdit.INDENT;
  ev = {
    preventDefault: function() {}
  };
  region = null;
  root = ContentEdit.Root.get();
  beforeEach(function() {
    var content, j, len, ref, results;
    region = new ContentEdit.Region(document.getElementById('test'));
    ref = ['foo', 'bar', 'zee'];
    results = [];
    for (j = 0, len = ref.length; j < len; j++) {
      content = ref[j];
      results.push(region.attach(new ContentEdit.Text('p', {}, content)));
    }
    return results;
  });
  afterEach(function() {
    var child, j, len, ref, results;
    ref = region.children.slice();
    results = [];
    for (j = 0, len = ref.length; j < len; j++) {
      child = ref[j];
      results.push(region.detach(child));
    }
    return results;
  });
  it('should support down arrow nav to next content element', function() {
    var text;
    text = region.children[0];
    text.focus();
    new ContentSelect.Range(3, 3).select(text.domElement());
    text._keyDown(ev);
    return expect(root.focused()).toBe(region.children[1]);
  });
  it('should support left arrow nav to previous content element', function() {
    var text;
    text = region.children[1];
    text.focus();
    new ContentSelect.Range(0, 0).select(text.domElement());
    text._keyLeft(ev);
    return expect(root.focused()).toBe(region.children[0]);
  });
  it('should support right arrow nav to next content element', function() {
    var text;
    text = region.children[0];
    text.focus();
    new ContentSelect.Range(3, 3).select(text.domElement());
    text._keyRight(ev);
    return expect(root.focused()).toBe(region.children[1]);
  });
  it('should support up arrow nav to previous content element', function() {
    var text;
    text = region.children[1];
    text.focus();
    new ContentSelect.Range(0, 0).select(text.domElement());
    text._keyUp(ev);
    return expect(root.focused()).toBe(region.children[0]);
  });
  it('should support delete merge with next content element', function() {
    var text;
    text = region.children[0];
    text.focus();
    new ContentSelect.Range(3, 3).select(text.domElement());
    text._keyDelete(ev);
    return expect(text.content.text()).toBe('foobar');
  });
  it('should support backspace merge with previous content element', function() {
    var text;
    text = region.children[1];
    text.focus();
    new ContentSelect.Range(0, 0).select(text.domElement());
    text._keyBack(ev);
    return expect(region.children[0].content.text()).toBe('foobar');
  });
  it('should support return splitting the element into 2', function() {
    var text;
    text = region.children[0];
    text.focus();
    new ContentSelect.Range(2, 2).select(text.domElement());
    text._keyReturn(ev);
    expect(region.children[0].content.text()).toBe('fo');
    return expect(region.children[1].content.text()).toBe('o');
  });
  return it('should support shift+return inserting a line break', function() {
    var text;
    text = region.children[0];
    text.focus();
    new ContentSelect.Range(2, 2).select(text.domElement());
    ev.shiftKey = true;
    text._keyReturn(ev);
    return expect(region.children[0].content.html()).toBe('fo<br>o');
  });
});

describe('`ContentEdit.Text` drop interactions`', function() {
  var region, text;
  region = null;
  text = null;
  beforeEach(function() {
    region = new ContentEdit.Region(document.createElement('div'));
    text = new ContentEdit.Text('p', {}, 'foo');
    return region.attach(text);
  });
  it('should support dropping on Text', function() {
    var otherText;
    otherText = new ContentEdit.Text('p', {}, 'bar');
    region.attach(otherText);
    expect(text.nextSibling()).toBe(otherText);
    text.drop(otherText, ['below', 'center']);
    expect(otherText.nextSibling()).toBe(text);
    text.drop(otherText, ['above', 'center']);
    return expect(text.nextSibling()).toBe(otherText);
  });
  it('should support dropping on Static', function() {
    var staticElm;
    staticElm = ContentEdit.Static.fromDOMElement(document.createElement('div'));
    region.attach(staticElm);
    expect(text.nextSibling()).toBe(staticElm);
    text.drop(staticElm, ['below', 'center']);
    expect(staticElm.nextSibling()).toBe(text);
    text.drop(staticElm, ['above', 'center']);
    return expect(text.nextSibling()).toBe(staticElm);
  });
  return it('should support being dropped on by `moveable` Static', function() {
    var staticElm;
    staticElm = new ContentEdit.Static('div', {
      'data-ce-moveable': 'data-ce-moveable'
    }, 'foo');
    region.attach(staticElm, 0);
    expect(staticElm.nextSibling()).toBe(text);
    staticElm.drop(text, ['below', 'center']);
    expect(text.nextSibling()).toBe(staticElm);
    staticElm.drop(text, ['above', 'center']);
    return expect(staticElm.nextSibling()).toBe(text);
  });
});

describe('`ContentEdit.Text` merge interactions`', function() {
  var region, text;
  text = null;
  region = null;
  beforeEach(function() {
    region = new ContentEdit.Region(document.getElementById('test'));
    text = new ContentEdit.Text('p', {}, 'foo');
    return region.attach(text);
  });
  afterEach(function() {
    var child, j, len, ref, results;
    ref = region.children.slice();
    results = [];
    for (j = 0, len = ref.length; j < len; j++) {
      child = ref[j];
      results.push(region.detach(child));
    }
    return results;
  });
  return it('should support merging with Text', function() {
    var otherText;
    otherText = new ContentEdit.Text('p', {}, 'bar');
    region.attach(otherText);
    text.merge(otherText);
    expect(text.html()).toBe("<p>\n" + ContentEdit.INDENT + "foobar\n</p>");
    return expect(otherText.parent()).toBe(null);
  });
});

describe('`ContentEdit.PreText()`', function() {
  return it('should return an instance of PreText`', function() {
    var preText;
    preText = new ContentEdit.PreText('pre', {}, 'foo <b>bar</b>');
    return expect(preText instanceof ContentEdit.PreText).toBe(true);
  });
});

describe('`ContentEdit.PreText.cssTypeName()`', function() {
  return it('should return \'pre-text\'', function() {
    var preText;
    preText = new ContentEdit.PreText('pre', {}, 'foo <b>bar</b>');
    return expect(preText.cssTypeName()).toBe('pre-text');
  });
});

describe('`ContentEdit.PreText.type()`', function() {
  return it('should return \'PreText\'', function() {
    var preText;
    preText = new ContentEdit.PreText('pre', {}, 'foo <b>bar</b>');
    return expect(preText.type()).toBe('PreText');
  });
});

describe('`ContentEdit.PreText.typeName()`', function() {
  return it('should return \'Preformatted\'', function() {
    var preText;
    preText = new ContentEdit.PreText('pre', {}, 'foo <b>bar</b>');
    return expect(preText.typeName()).toBe('Preformatted');
  });
});

describe('ContentEdit.PreText.html()', function() {
  return it('should return a HTML string for the pre-text element', function() {
    var I, preText;
    I = ContentEdit.INDENT;
    preText = new ContentEdit.PreText('pre', {
      'class': 'foo'
    }, "&lt;div&gt;\n    test &amp; test\n&lt;/div&gt;");
    return expect(preText.html()).toBe("<pre class=\"foo\">&lt;div&gt;\n" + ContentEdit.INDENT + "test &amp; test\n&lt;/div&gt;</pre>");
  });
});

describe('`ContentEdit.PreText.fromDOMElement()`', function() {
  return it('should convert a <pre> DOM element into a preserved text element', function() {
    var I, domDiv, preText;
    I = ContentEdit.INDENT;
    domDiv = document.createElement('div');
    domDiv.innerHTML = "<pre>&lt;div&gt;\n" + ContentEdit.INDENT + "test &amp; test\n&lt;/div&gt;</pre>";
    preText = ContentEdit.PreText.fromDOMElement(domDiv.childNodes[0]);
    return expect(preText.html()).toBe("<pre>&lt;div&gt;\n" + ContentEdit.INDENT + "test &amp; test\n&lt;/div&gt;</pre>");
  });
});

describe('`ContentEdit.PreText` key events`', function() {
  var I, ev, preText, region, root;
  I = ContentEdit.INDENT;
  ev = {
    preventDefault: function() {}
  };
  region = null;
  preText = null;
  root = ContentEdit.Root.get();
  beforeEach(function() {
    region = new ContentEdit.Region(document.getElementById('test'));
    preText = new ContentEdit.PreText('pre', {
      'class': 'foo'
    }, "&lt;div&gt;\n" + ContentEdit.INDENT + "test &amp; test\n&lt;/div&gt;");
    return region.attach(preText);
  });
  afterEach(function() {
    var child, j, len, ref, results;
    ref = region.children.slice();
    results = [];
    for (j = 0, len = ref.length; j < len; j++) {
      child = ref[j];
      results.push(region.detach(child));
    }
    return results;
  });
  return it('should support return adding a newline', function() {
    preText.focus();
    new ContentSelect.Range(13, 13).select(preText.domElement());
    preText._keyReturn(ev);
    return expect(preText.html()).toBe("<pre class=\"foo\">&lt;div&gt;\n" + ContentEdit.INDENT + "tes\nt &amp; test\n&lt;/div&gt;</pre>");
  });
});

describe('`ContentEdit.PreText` drop interactions`', function() {
  var preText, region;
  region = null;
  preText = null;
  beforeEach(function() {
    region = new ContentEdit.Region(document.createElement('div'));
    preText = new ContentEdit.PreText('p', {}, 'foo');
    return region.attach(preText);
  });
  it('should support dropping on PreText', function() {
    var otherPreText;
    otherPreText = new ContentEdit.PreText('pre', {}, '');
    region.attach(otherPreText);
    expect(preText.nextSibling()).toBe(otherPreText);
    preText.drop(otherPreText, ['below', 'center']);
    expect(otherPreText.nextSibling()).toBe(preText);
    preText.drop(otherPreText, ['above', 'center']);
    return expect(preText.nextSibling()).toBe(otherPreText);
  });
  it('should support dropping on Static', function() {
    var staticElm;
    staticElm = ContentEdit.Static.fromDOMElement(document.createElement('div'));
    region.attach(staticElm);
    expect(preText.nextSibling()).toBe(staticElm);
    preText.drop(staticElm, ['below', 'center']);
    expect(staticElm.nextSibling()).toBe(preText);
    preText.drop(staticElm, ['above', 'center']);
    return expect(preText.nextSibling()).toBe(staticElm);
  });
  it('should support being dropped on by `moveable` Static', function() {
    var staticElm;
    staticElm = new ContentEdit.Static('div', {
      'data-ce-moveable': 'data-ce-moveable'
    }, 'foo');
    region.attach(staticElm, 0);
    expect(staticElm.nextSibling()).toBe(preText);
    staticElm.drop(preText, ['below', 'center']);
    expect(preText.nextSibling()).toBe(staticElm);
    staticElm.drop(preText, ['above', 'center']);
    return expect(staticElm.nextSibling()).toBe(preText);
  });
  it('should support dropping on Text', function() {
    var text;
    text = new ContentEdit.Text('p');
    region.attach(text);
    expect(preText.nextSibling()).toBe(text);
    preText.drop(text, ['below', 'center']);
    expect(text.nextSibling()).toBe(preText);
    preText.drop(text, ['above', 'center']);
    return expect(preText.nextSibling()).toBe(text);
  });
  return it('should support being dropped on by Text', function() {
    var text;
    text = new ContentEdit.Text('p');
    region.attach(text, 0);
    expect(text.nextSibling()).toBe(preText);
    text.drop(preText, ['below', 'center']);
    expect(preText.nextSibling()).toBe(text);
    text.drop(preText, ['above', 'center']);
    return expect(text.nextSibling()).toBe(preText);
  });
});
