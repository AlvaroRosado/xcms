// Generated by CoffeeScript 1.10.0
var testDomElement;

testDomElement = document.createElement('div');

testDomElement.setAttribute('id', 'test');

document.body.appendChild(testDomElement);

describe('ContentEdit.Node()', function() {
  return it('should create `ContentEdit.Node` instance', function() {
    var node;
    node = new ContentEdit.Node();
    return expect(node instanceof ContentEdit.Node).toBe(true);
  });
});

describe('ContentEdit.Node.lastModified()', function() {
  return it('should return a date last modified if the node has been tainted', function() {
    var node;
    node = new ContentEdit.Node();
    expect(node.lastModified()).toBe(null);
    node.taint();
    return expect(node.lastModified()).not.toBe(null);
  });
});

describe('ContentEdit.Node.parent()', function() {
  return it('should return the parent node collection for the node', function() {
    var collection, node;
    collection = new ContentEdit.NodeCollection();
    node = new ContentEdit.Node();
    collection.attach(node);
    return expect(node.parent()).toBe(collection);
  });
});

describe('ContentEdit.Node.parents()', function() {
  return it('should return an ascending list of all the node\'s parents', function() {
    var grandParent, node, parent;
    grandParent = new ContentEdit.NodeCollection();
    parent = new ContentEdit.NodeCollection();
    grandParent.attach(parent);
    node = new ContentEdit.Node();
    parent.attach(node);
    return expect(node.parents()).toEqual([parent, grandParent]);
  });
});

describe('ContentEdit.Node.html()', function() {
  return it('should raise a not implemented error', function() {
    var node;
    node = new ContentEdit.Node();
    return expect(node.html).toThrow(new Error('`html` not implemented'));
  });
});

describe('ContentEdit.Node.type()', function() {
  return it('should return \'Node\'', function() {
    var node;
    node = new ContentEdit.Node();
    return expect(node.type()).toBe('Node');
  });
});

describe('ContentEdit.Node.bind()', function() {
  return it('should bind a function so that it\'s called whenever the event is triggered', function() {
    var foo, node;
    foo = {
      handleFoo: function() {}
    };
    spyOn(foo, 'handleFoo');
    node = new ContentEdit.Node();
    node.bind('foo', foo.handleFoo);
    node.trigger('foo');
    return expect(foo.handleFoo).toHaveBeenCalled();
  });
});

describe('ContentEdit.Node.trigger()', function() {
  return it('should trigger an event against the node with specified arguments', function() {
    var foo, node;
    foo = {
      handleFoo: function() {}
    };
    spyOn(foo, 'handleFoo');
    node = new ContentEdit.Node();
    node.bind('foo', foo.handleFoo);
    node.trigger('foo', 123);
    return expect(foo.handleFoo).toHaveBeenCalledWith(123);
  });
});

describe('ContentEdit.Node.unbind()', function() {
  return it('should unbind a function previously bound for an event from the node', function() {
    var foo, node;
    foo = {
      handleFoo: function() {}
    };
    spyOn(foo, 'handleFoo');
    node = new ContentEdit.Node();
    node.bind('foo', foo.handleFoo);
    node.unbind('foo', foo.handleFoo);
    node.trigger('foo');
    return expect(foo.handleFoo).not.toHaveBeenCalled();
  });
});

describe('ContentEdit.Node.commit()', function() {
  var node;
  node = null;
  beforeEach(function() {
    node = new ContentEdit.Node();
    return node.taint();
  });
  it('should set the last modified date of the node to null', function() {
    node.commit();
    return expect(node.lastModified()).toBe(null);
  });
  return it('should trigger the commit event against the root', function() {
    var foo, root;
    foo = {
      handleFoo: function() {}
    };
    spyOn(foo, 'handleFoo');
    root = ContentEdit.Root.get();
    root.bind('commit', foo.handleFoo);
    node.commit();
    return expect(foo.handleFoo).toHaveBeenCalledWith(node);
  });
});

describe('ContentEdit.Node.taint()', function() {
  it('should set the last modified date of the node, it\'s parents and the root', function() {
    var collection, node;
    collection = new ContentEdit.NodeCollection();
    node = new ContentEdit.Node();
    collection.attach(node);
    node.taint();
    expect(node.lastModified()).not.toBe(null);
    expect(node.parent().lastModified()).toBe(node.lastModified());
    return expect(ContentEdit.Root.get().lastModified()).toBe(node.lastModified());
  });
  return it('should trigger the taint event against the root', function() {
    var foo, node, root;
    node = new ContentEdit.Node();
    foo = {
      handleFoo: function() {}
    };
    spyOn(foo, 'handleFoo');
    root = ContentEdit.Root.get();
    root.bind('taint', foo.handleFoo);
    node.taint();
    return expect(foo.handleFoo).toHaveBeenCalledWith(node);
  });
});

describe('ContentEdit.Node.closest()', function() {
  return it('should return the first ancestor (ascending order) to match the that returns true for the specified test function.', function() {
    var grandParent, node, parent;
    grandParent = new ContentEdit.NodeCollection();
    parent = new ContentEdit.NodeCollection();
    grandParent.attach(parent);
    node = new ContentEdit.Node();
    parent.attach(node);
    grandParent.foo = true;
    parent.bar = true;
    expect(node.closest(function(node) {
      return node.foo;
    })).toBe(grandParent);
    return expect(node.closest(function(node) {
      return node.bar;
    })).toBe(parent);
  });
});

describe('ContentEdit.Node.next()', function() {
  return it('should return the node next to this node in the tree', function() {
    var collectionA, collectionB, nodeA, nodeB;
    collectionA = new ContentEdit.NodeCollection();
    nodeA = new ContentEdit.Node();
    collectionA.attach(nodeA);
    collectionB = new ContentEdit.NodeCollection();
    nodeB = new ContentEdit.Node();
    collectionA.attach(collectionB);
    collectionB.attach(nodeB);
    expect(nodeA.next()).toBe(collectionB);
    return expect(nodeA.next().next()).toBe(nodeB);
  });
});

describe('ContentEdit.Node.nextContent()', function() {
  return it('should return the next node in the tree that supports the `content` attribute', function() {
    var collectionA, collectionB, nodeA, nodeB;
    collectionA = new ContentEdit.NodeCollection();
    nodeA = new ContentEdit.Node();
    collectionA.attach(nodeA);
    collectionB = new ContentEdit.NodeCollection();
    nodeB = new ContentEdit.Text('p', {}, 'testing');
    collectionA.attach(collectionB);
    collectionB.attach(nodeB);
    return expect(collectionA.nextContent()).toBe(nodeB);
  });
});

describe('ContentEdit.Node.nextSibling()', function() {
  return it('should return the node next to this node with the same parent', function() {
    var collection, nodeA, nodeB;
    collection = new ContentEdit.NodeCollection();
    nodeA = new ContentEdit.Node();
    collection.attach(nodeA);
    nodeB = new ContentEdit.Node();
    collection.attach(nodeB);
    return expect(nodeA.nextSibling()).toBe(nodeB);
  });
});

describe('ContentEdit.Node.nextWithTest()', function() {
  return it('should return the next node in the tree that matches or `undefined` if there are none', function() {
    var collectionA, collectionB, nodeA, nodeB;
    collectionA = new ContentEdit.NodeCollection();
    nodeA = new ContentEdit.Node();
    collectionA.attach(nodeA);
    collectionB = new ContentEdit.NodeCollection();
    nodeB = new ContentEdit.Node();
    collectionA.attach(collectionB);
    collectionB.attach(nodeB);
    nodeB.foo = true;
    expect(collectionA.nextWithTest(function(node) {
      return node.foo;
    })).toBe(nodeB);
    return expect(nodeB.nextWithTest(function(node) {
      return node.foo;
    })).toBe(void 0);
  });
});

describe('ContentEdit.Node.previous()', function() {
  return it('should return the node previous to this node in the tree', function() {
    var collectionA, collectionB, nodeA, nodeB;
    collectionA = new ContentEdit.NodeCollection();
    nodeA = new ContentEdit.Node();
    collectionA.attach(nodeA);
    collectionB = new ContentEdit.NodeCollection();
    nodeB = new ContentEdit.Node();
    collectionA.attach(collectionB);
    collectionB.attach(nodeB);
    expect(nodeB.previous()).toBe(collectionB);
    return expect(nodeB.previous().previous()).toBe(nodeA);
  });
});

describe('ContentEdit.Node.nextContent()', function() {
  return it('should return the previous node in the tree that supports the `content` attribute', function() {
    var collectionA, collectionB, nodeA, nodeB;
    collectionA = new ContentEdit.NodeCollection();
    nodeA = new ContentEdit.Text('p', {}, 'testing');
    collectionA.attach(nodeA);
    collectionB = new ContentEdit.NodeCollection();
    nodeB = new ContentEdit.Node();
    collectionA.attach(collectionB);
    collectionB.attach(nodeB);
    return expect(nodeB.previousContent()).toBe(nodeA);
  });
});

describe('ContentEdit.Node.previousSibling()', function() {
  return it('should return the node previous to this node with the same parent', function() {
    var collection, nodeA, nodeB;
    collection = new ContentEdit.NodeCollection();
    nodeA = new ContentEdit.Node();
    collection.attach(nodeA);
    nodeB = new ContentEdit.Node();
    collection.attach(nodeB);
    return expect(nodeB.previousSibling()).toBe(nodeA);
  });
});

describe('ContentEdit.Node.previousWithTest()', function() {
  return it('should return the previous node in the tree that matches or `undefined` if there are none', function() {
    var collectionA, collectionB, nodeA, nodeB;
    collectionA = new ContentEdit.NodeCollection();
    nodeA = new ContentEdit.Node();
    collectionA.attach(nodeA);
    collectionB = new ContentEdit.NodeCollection();
    nodeB = new ContentEdit.Node();
    collectionA.attach(collectionB);
    collectionB.attach(nodeB);
    nodeA.foo = true;
    expect(nodeB.previousWithTest(function(node) {
      return node.foo;
    })).toBe(nodeA);
    return expect(collectionA.previousWithTest(function(node) {
      return node.foo;
    })).toBe(void 0);
  });
});

describe('ContentEdit.Node.@fromDOMElement()', function() {
  return it('should raise a not implemented error', function() {
    return expect(ContentEdit.Node.fromDOMElement).toThrow(new Error('`fromDOMElement` not implemented'));
  });
});

describe('ContentEdit.NodeCollection()', function() {
  return it('should create `ContentEdit.NodeCollection` instance', function() {
    var collection;
    collection = new ContentEdit.NodeCollection();
    return expect(collection instanceof ContentEdit.NodeCollection).toBe(true);
  });
});

describe('ContentEdit.NodeCollection.descendants()', function() {
  return it('should return a (flat) list of all the descendants for the collection', function() {
    var collectionA, collectionB, nodeA, nodeB;
    collectionA = new ContentEdit.NodeCollection();
    nodeA = new ContentEdit.Node();
    collectionA.attach(nodeA);
    collectionB = new ContentEdit.NodeCollection();
    nodeB = new ContentEdit.Node();
    collectionA.attach(collectionB);
    collectionB.attach(nodeB);
    return expect(collectionA.descendants()).toEqual([nodeA, collectionB, nodeB]);
  });
});

describe('ContentEdit.NodeCollection.isMounted()', function() {
  return it('should always return false', function() {
    var collection;
    collection = new ContentEdit.NodeCollection();
    return expect(collection.isMounted()).toBe(false);
  });
});

describe('ContentEdit.NodeCollection.type()', function() {
  return it('should return \'NodeCollection\'', function() {
    var collection;
    collection = new ContentEdit.NodeCollection();
    return expect(collection.type()).toBe('NodeCollection');
  });
});

describe('ContentEdit.NodeCollection.attach()', function() {
  it('should attach a node to a node collection', function() {
    var collection, node;
    collection = new ContentEdit.NodeCollection();
    node = new ContentEdit.Node();
    collection.attach(node);
    return expect(collection.children[0]).toBe(node);
  });
  it('should attach a node to a node collection at the specified index', function() {
    var collection, i, j, node, otherNode;
    collection = new ContentEdit.NodeCollection();
    for (i = j = 0; j < 5; i = ++j) {
      otherNode = new ContentEdit.Node();
      collection.attach(otherNode);
    }
    node = new ContentEdit.Node();
    collection.attach(node, 2);
    return expect(collection.children[2]).toBe(node);
  });
  return it('should trigger the attach event against the root', function() {
    var collection, foo, node, root;
    foo = {
      handleFoo: function() {}
    };
    spyOn(foo, 'handleFoo');
    root = ContentEdit.Root.get();
    root.bind('attach', foo.handleFoo);
    collection = new ContentEdit.NodeCollection();
    node = new ContentEdit.Node();
    collection.attach(node);
    return expect(foo.handleFoo).toHaveBeenCalledWith(collection, node);
  });
});

describe('ContentEdit.NodeCollection.commit()', function() {
  var collectionA, collectionB, node;
  collectionA = null;
  collectionB = null;
  node = null;
  beforeEach(function() {
    collectionA = new ContentEdit.NodeCollection();
    collectionB = new ContentEdit.NodeCollection();
    node = new ContentEdit.Node();
    collectionA.attach(collectionB);
    return collectionB.attach(node);
  });
  it('should set the last modified date of the node and it\'s descendants to null', function() {
    node.taint();
    expect(collectionA.lastModified()).not.toBe(null);
    node.commit();
    return expect(node.lastModified()).toBe(null);
  });
  return it('should trigger the commit event against the root', function() {
    var foo, root;
    foo = {
      handleFoo: function() {}
    };
    spyOn(foo, 'handleFoo');
    root = ContentEdit.Root.get();
    root.bind('commit', foo.handleFoo);
    collectionA.commit();
    return expect(foo.handleFoo).toHaveBeenCalledWith(collectionA);
  });
});

describe('ContentEdit.NodeCollection.detach()', function() {
  var collection, node;
  collection = null;
  node = null;
  beforeEach(function() {
    collection = new ContentEdit.NodeCollection();
    node = new ContentEdit.Node();
    return collection.attach(node);
  });
  it('should detach a node from the node collection', function() {
    collection.detach(node);
    expect(collection.children.length).toBe(0);
    return expect(node.parent()).toBe(null);
  });
  return it('should trigger the detach event against the root', function() {
    var foo, root;
    foo = {
      handleFoo: function() {}
    };
    spyOn(foo, 'handleFoo');
    root = ContentEdit.Root.get();
    root.bind('detach', foo.handleFoo);
    collection.detach(node);
    return expect(foo.handleFoo).toHaveBeenCalledWith(collection, node);
  });
});

describe('ContentEdit.Element()', function() {
  return it('should create `ContentEdit.Element` instance', function() {
    var element;
    element = new ContentEdit.Element('div', {
      'class': 'foo'
    });
    return expect(element instanceof ContentEdit.Element).toBe(true);
  });
});

describe('ContentEdit.Element.attributes()', function() {
  return it('should return a copy of the elements attributes', function() {
    var element;
    element = new ContentEdit.Element('div', {
      'class': 'foo',
      'data-test': ''
    });
    return expect(element.attributes()).toEqual({
      'class': 'foo',
      'data-test': ''
    });
  });
});

describe('ContentEdit.Element.cssTypeName()', function() {
  return it('should return \'element\'', function() {
    var element;
    element = new ContentEdit.Element('div', {
      'class': 'foo'
    });
    return expect(element.cssTypeName()).toBe('element');
  });
});

describe('ContentEdit.Element.domElement()', function() {
  return it('should return a DOM element if mounted', function() {
    var element, region;
    element = new ContentEdit.Text('p');
    expect(element.domElement()).toBe(null);
    region = new ContentEdit.Region(document.createElement('div'));
    region.attach(element);
    return expect(element.domElement()).not.toBe(null);
  });
});

describe('ContentEdit.Element.isFocused()', function() {
  return it('should return true if element is focused', function() {
    var element;
    element = new ContentEdit.Element('div');
    expect(element.isFocused()).toBe(false);
    element.focus();
    return expect(element.isFocused()).toBe(true);
  });
});

describe('ContentEdit.Element.isMounted()', function() {
  return it('should return true if the element is mounted in the DOM', function() {
    var element, region;
    element = new ContentEdit.Text('p');
    expect(element.isMounted()).toBe(false);
    region = new ContentEdit.Region(document.createElement('div'));
    region.attach(element);
    return expect(element.isMounted()).toBe(true);
  });
});

describe('ContentEdit.Element.type()', function() {
  return it('should return \'Element\'', function() {
    var element;
    element = new ContentEdit.Element('div', {
      'class': 'foo'
    });
    return expect(element.type()).toBe('Element');
  });
});

describe('`ContentEdit.Element.typeName()`', function() {
  return it('should return \'Element\'', function() {
    var element;
    element = new ContentEdit.Element('div', {
      'class': 'foo'
    });
    return expect(element.typeName()).toBe('Element');
  });
});

describe('ContentEdit.Element.addCSSClass()', function() {
  return it('should add a CSS class to the element', function() {
    var element;
    element = new ContentEdit.Element('div');
    element.addCSSClass('foo');
    expect(element.hasCSSClass('foo')).toBe(true);
    element.addCSSClass('bar');
    return expect(element.hasCSSClass('bar')).toBe(true);
  });
});

describe('ContentEdit.Element.attr()', function() {
  return it('should set/get an attribute for the element', function() {
    var element;
    element = new ContentEdit.Element('div');
    element.attr('foo', 'bar');
    return expect(element.attr('foo')).toBe('bar');
  });
});

describe('ContentEdit.Element.blur()', function() {
  it('should blur an element', function() {
    var element;
    element = new ContentEdit.Element('div');
    element.focus();
    expect(element.isFocused()).toBe(true);
    element.blur();
    return expect(element.isFocused()).toBe(false);
  });
  return it('should trigger the `blur` event against the root', function() {
    var element, foo, root;
    foo = {
      handleFoo: function() {}
    };
    spyOn(foo, 'handleFoo');
    root = ContentEdit.Root.get();
    root.bind('blur', foo.handleFoo);
    element = new ContentEdit.Element('div');
    element.focus();
    element.blur();
    return expect(foo.handleFoo).toHaveBeenCalledWith(element);
  });
});

describe('ContentEdit.Element.createDraggingDOMElement()', function() {
  return it('should create a helper DOM element', function() {
    var element, helper, region;
    element = new ContentEdit.Element('div');
    region = new ContentEdit.Region(document.createElement('div'));
    region.attach(element);
    helper = element.createDraggingDOMElement();
    expect(helper).not.toBe(null);
    return expect(helper.tagName.toLowerCase()).toBe('div');
  });
});

describe('ContentEdit.Element.drag()', function() {
  it('should call `startDragging` against the root element', function() {
    var element, region, root;
    element = new ContentEdit.Element('div');
    region = new ContentEdit.Region(document.createElement('div'));
    region.attach(element);
    root = ContentEdit.Root.get();
    spyOn(root, 'startDragging');
    element.drag(0, 0);
    expect(root.startDragging).toHaveBeenCalledWith(element, 0, 0);
    return root.cancelDragging();
  });
  return it('should trigger the `drag` event against the root', function() {
    var element, foo, region, root;
    element = new ContentEdit.Element('div');
    region = new ContentEdit.Region(document.createElement('div'));
    region.attach(element);
    foo = {
      handleFoo: function() {}
    };
    spyOn(foo, 'handleFoo');
    root = ContentEdit.Root.get();
    root.bind('drag', foo.handleFoo);
    element.drag(0, 0);
    expect(foo.handleFoo).toHaveBeenCalledWith(element);
    return root.cancelDragging();
  });
});

describe('ContentEdit.Element.drop()', function() {
  it('should select a function from the elements droppers map for the element being dropped on to this element', function() {
    var imageA, imageB, region;
    region = new ContentEdit.Region(document.createElement('div'));
    imageA = new ContentEdit.Image();
    region.attach(imageA);
    imageB = new ContentEdit.Image();
    region.attach(imageB);
    spyOn(ContentEdit.Image.droppers, 'Image');
    imageA.drop(imageB, ['below', 'center']);
    return expect(ContentEdit.Image.droppers['Image']).toHaveBeenCalledWith(imageA, imageB, ['below', 'center']);
  });
  return it('should trigger the `drop` event against the root', function() {
    var foo, imageA, imageB, region, root;
    region = new ContentEdit.Region(document.createElement('div'));
    imageA = new ContentEdit.Image();
    region.attach(imageA);
    imageB = new ContentEdit.Image();
    region.attach(imageB);
    foo = {
      handleFoo: function() {}
    };
    spyOn(foo, 'handleFoo');
    root = ContentEdit.Root.get();
    root.bind('drop', foo.handleFoo);
    imageA.drop(imageB, ['below', 'center']);
    expect(foo.handleFoo).toHaveBeenCalledWith(imageA, imageB, ['below', 'center']);
    imageA.drop(null, ['below', 'center']);
    return expect(foo.handleFoo).toHaveBeenCalledWith(imageA, null, null);
  });
});

describe('ContentEdit.Element.focus()', function() {
  it('should focus an element', function() {
    var element;
    element = new ContentEdit.Element('div');
    element.focus();
    return expect(element.isFocused()).toBe(true);
  });
  return it('should trigger the `focus` event against the root', function() {
    var element, foo, root;
    foo = {
      handleFoo: function() {}
    };
    spyOn(foo, 'handleFoo');
    root = ContentEdit.Root.get();
    root.bind('focus', foo.handleFoo);
    element = new ContentEdit.Element('div');
    element.focus();
    return expect(foo.handleFoo).toHaveBeenCalledWith(element);
  });
});

describe('ContentEdit.Element.hasCSSClass()', function() {
  return it('should return true if the element has the specified class', function() {
    var element;
    element = new ContentEdit.Element('div');
    element.addCSSClass('foo');
    element.addCSSClass('bar');
    expect(element.hasCSSClass('foo')).toBe(true);
    return expect(element.hasCSSClass('bar')).toBe(true);
  });
});

describe('ContentEdit.Element.merge()', function() {
  return it('should select a function from the elements mergers map for the element being merged with this element', function() {
    var region, textA, textB;
    region = new ContentEdit.Region(document.createElement('div'));
    textA = new ContentEdit.Text('p', {}, 'a');
    region.attach(textA);
    textB = new ContentEdit.Text('p', {}, 'b');
    region.attach(textB);
    spyOn(ContentEdit.Text.mergers, 'Text');
    textA.merge(textB);
    return expect(ContentEdit.Text.mergers['Text']).toHaveBeenCalledWith(textB, textA);
  });
});

describe('ContentEdit.Element.mount()', function() {
  var element, region;
  element = null;
  region = null;
  beforeEach(function() {
    element = new ContentEdit.Element('p');
    region = new ContentEdit.Region(document.createElement('div'));
    region.attach(element);
    return element.unmount();
  });
  it('should mount the element to the DOM', function() {
    element.mount();
    return expect(element.isMounted()).toBe(true);
  });
  return it('should trigger the `mount` event against the root', function() {
    var foo, root;
    foo = {
      handleFoo: function() {}
    };
    spyOn(foo, 'handleFoo');
    root = ContentEdit.Root.get();
    root.bind('mount', foo.handleFoo);
    element.mount();
    return expect(foo.handleFoo).toHaveBeenCalledWith(element);
  });
});

describe('ContentEdit.Element.removeAttr()', function() {
  return it('should remove an attribute from the element', function() {
    var element;
    element = new ContentEdit.Element('div');
    element.attr('foo', 'bar');
    expect(element.attr('foo')).toBe('bar');
    element.removeAttr('foo');
    return expect(element.attr('foo')).toBe(void 0);
  });
});

describe('ContentEdit.Element.removeCSSClass()', function() {
  return it('should remove a CSS class from the element', function() {
    var element;
    element = new ContentEdit.Element('div');
    element.addCSSClass('foo');
    element.addCSSClass('bar');
    expect(element.hasCSSClass('foo')).toBe(true);
    expect(element.hasCSSClass('bar')).toBe(true);
    element.removeCSSClass('foo');
    element.hasCSSClass('foo');
    element.removeCSSClass('bar');
    return expect(element.hasCSSClass('bar')).toBe(false);
  });
});

describe('ContentEdit.Element.tagName()', function() {
  return it('should set/get the tag name for the element', function() {
    var element;
    element = new ContentEdit.Element('div');
    expect(element.tagName()).toBe('div');
    element.tagName('dt');
    return expect(element.tagName()).toBe('dt');
  });
});

describe('ContentEdit.Element.unmount()', function() {
  var element, region;
  element = null;
  region = null;
  beforeEach(function() {
    element = new ContentEdit.Element('p');
    region = new ContentEdit.Region(document.createElement('div'));
    return region.attach(element);
  });
  it('should unmount the element from the DOM', function() {
    element.unmount();
    return expect(element.isMounted()).toBe(false);
  });
  return it('should trigger the `unmount` event against the root', function() {
    var foo, root;
    foo = {
      handleFoo: function() {}
    };
    spyOn(foo, 'handleFoo');
    root = ContentEdit.Root.get();
    root.bind('unmount', foo.handleFoo);
    element.unmount();
    return expect(foo.handleFoo).toHaveBeenCalledWith(element);
  });
});

describe('ContentEdit.Element.@getDOMElementAttributes()', function() {
  return it('should return attributes from a DOM element as a dictionary', function() {
    var attributes, domElement;
    domElement = document.createElement('div');
    domElement.setAttribute('class', 'foo');
    domElement.setAttribute('id', 'bar');
    domElement.setAttribute('contenteditable', '');
    attributes = ContentEdit.Element.getDOMElementAttributes(domElement);
    return expect(attributes).toEqual({
      'class': 'foo',
      'id': 'bar',
      'contenteditable': ''
    });
  });
});

describe('ContentEdit.ElementCollection()', function() {
  return it('should create `ContentEdit.ElementCollection` instance`', function() {
    var collection;
    collection = new ContentEdit.ElementCollection('dl', {
      'class': 'foo'
    });
    return expect(collection instanceof ContentEdit.ElementCollection).toBe(true);
  });
});

describe('ContentEdit.ElementCollection.cssTypeName()', function() {
  return it('should return \'element-collection\'', function() {
    var element;
    element = new ContentEdit.ElementCollection('div', {
      'class': 'foo'
    });
    return expect(element.cssTypeName()).toBe('element-collection');
  });
});

describe('ContentEdit.ElementCollection.isMounted()', function() {
  return it('should return true if the element is mounted in the DOM', function() {
    var collection, region;
    collection = new ContentEdit.List('ul');
    expect(collection.isMounted()).toBe(false);
    region = new ContentEdit.Region(document.createElement('div'));
    region.attach(collection);
    return expect(collection.isMounted()).toBe(true);
  });
});

describe('ContentEdit.ElementCollection.html()', function() {
  return it('should return a HTML string for the collection', function() {
    var collection, text;
    collection = new ContentEdit.ElementCollection('div', {
      'class': 'foo'
    });
    text = new ContentEdit.Text('p', {}, 'test');
    collection.attach(text);
    return expect(collection.html()).toBe('<div class="foo">\n' + (ContentEdit.INDENT + "<p>\n") + ("" + ContentEdit.INDENT + ContentEdit.INDENT + "test\n") + (ContentEdit.INDENT + "</p>\n") + '</div>');
  });
});

describe('`ContentEdit.ElementCollection.type()`', function() {
  return it('should return \'ElementCollection\'', function() {
    var collection;
    collection = new ContentEdit.ElementCollection('div', {
      'class': 'foo'
    });
    return expect(collection.type()).toBe('ElementCollection');
  });
});

describe('ContentEdit.ElementCollection.createDraggingDOMElement()', function() {
  return it('should create a helper DOM element', function() {
    var collection, element, helper, region;
    collection = new ContentEdit.ElementCollection('div');
    element = new ContentEdit.Element('p');
    collection.attach(element);
    region = new ContentEdit.Region(document.createElement('div'));
    region.attach(collection);
    helper = collection.createDraggingDOMElement();
    expect(helper).not.toBe(null);
    return expect(helper.tagName.toLowerCase()).toBe('div');
  });
});

describe('ContentEdit.ElementCollection.detach()', function() {
  var collection, elementA, elementB, region;
  collection = null;
  elementA = null;
  elementB = null;
  region = null;
  beforeEach(function() {
    region = new ContentEdit.Region(document.createElement('div'));
    collection = new ContentEdit.ElementCollection('div');
    region.attach(collection);
    elementA = new ContentEdit.Element('p');
    collection.attach(elementA);
    elementB = new ContentEdit.Element('p');
    return collection.attach(elementB);
  });
  it('should detach an element from the element collection', function() {
    collection.detach(elementA);
    return expect(collection.children.length).toBe(1);
  });
  it('should remove the collection if it becomes empty', function() {
    collection.detach(elementA);
    collection.detach(elementB);
    return expect(region.children.length).toBe(0);
  });
  return it('should trigger the detach event against the root', function() {
    var foo, root;
    foo = {
      handleFoo: function() {}
    };
    spyOn(foo, 'handleFoo');
    root = ContentEdit.Root.get();
    root.bind('detach', foo.handleFoo);
    collection.detach(elementA);
    return expect(foo.handleFoo).toHaveBeenCalledWith(collection, elementA);
  });
});

describe('ContentEdit.ElementCollection.mount()', function() {
  var collection, element, region;
  collection = null;
  element = null;
  region = null;
  beforeEach(function() {
    collection = new ContentEdit.ElementCollection('div');
    element = new ContentEdit.Element('p');
    collection.attach(element);
    region = new ContentEdit.Region(document.createElement('div'));
    region.attach(collection);
    return element.unmount();
  });
  it('should mount the collection and it\'s children to the DOM', function() {
    collection.mount();
    expect(collection.isMounted()).toBe(true);
    return expect(element.isMounted()).toBe(true);
  });
  return it('should trigger the `mount` event against the root', function() {
    var foo, root;
    foo = {
      handleFoo: function() {}
    };
    spyOn(foo, 'handleFoo');
    root = ContentEdit.Root.get();
    root.bind('mount', foo.handleFoo);
    collection.mount();
    expect(foo.handleFoo).toHaveBeenCalledWith(collection);
    return expect(foo.handleFoo).toHaveBeenCalledWith(element);
  });
});

describe('ContentEdit.ElementCollection.unmount()', function() {
  var collection, element, region;
  collection = null;
  element = null;
  region = null;
  beforeEach(function() {
    collection = new ContentEdit.ElementCollection('div');
    element = new ContentEdit.Element('p');
    collection.attach(element);
    region = new ContentEdit.Region(document.createElement('div'));
    return region.attach(collection);
  });
  it('should unmount the collection and it\'s children from the DOM', function() {
    collection.unmount();
    expect(collection.isMounted()).toBe(false);
    return expect(element.isMounted()).toBe(false);
  });
  return it('should trigger the `unmount` event against the root', function() {
    var foo, root;
    foo = {
      handleFoo: function() {}
    };
    spyOn(foo, 'handleFoo');
    root = ContentEdit.Root.get();
    root.bind('unmount', foo.handleFoo);
    collection.unmount();
    expect(foo.handleFoo).toHaveBeenCalledWith(collection);
    return expect(foo.handleFoo).toHaveBeenCalledWith(element);
  });
});

describe('ContentEdit.ResizableElement()', function() {
  return it('should create `ContentEdit.ResizableElement` instance`', function() {
    var element;
    element = new ContentEdit.ResizableElement('div', {
      'class': 'foo'
    });
    return expect(element instanceof ContentEdit.ResizableElement).toBe(true);
  });
});

describe('ContentEdit.ResizableElement.aspectRatio()', function() {
  return it('should return the 1', function() {
    var element;
    element = new ContentEdit.ResizableElement('div');
    return expect(element.aspectRatio()).toBe(1);
  });
});

describe('ContentEdit.ResizableElement.maxSize()', function() {
  var element;
  element = null;
  beforeEach(function() {
    return element = new ContentEdit.ResizableElement('div', {
      'height': 200,
      'width': 200
    });
  });
  it('should return the default maximum element size for an element', function() {
    return expect(element.maxSize()).toEqual([ContentEdit.DEFAULT_MAX_ELEMENT_WIDTH, ContentEdit.DEFAULT_MAX_ELEMENT_WIDTH]);
  });
  return it('should return the specified maximum element size for an element', function() {
    element.attr('data-ce-max-width', 1000);
    return expect(element.maxSize()).toEqual([1000, 1000]);
  });
});

describe('ContentEdit.ResizableElement.minSize()', function() {
  var element;
  element = null;
  beforeEach(function() {
    return element = new ContentEdit.ResizableElement('div', {
      'height': 200,
      'width': 200
    });
  });
  it('should return the default minimum element size for an element', function() {
    return expect(element.minSize()).toEqual([ContentEdit.DEFAULT_MIN_ELEMENT_WIDTH, ContentEdit.DEFAULT_MIN_ELEMENT_WIDTH]);
  });
  return it('should return the specified minimum element size for an element', function() {
    element.attr('data-ce-min-width', 100);
    return expect(element.minSize()).toEqual([100, 100]);
  });
});

describe('`ContentEdit.ResizableElement.type()`', function() {
  return it('should return \'ResizableElement\'', function() {
    var element;
    element = new ContentEdit.ResizableElement('div', {
      'class': 'foo'
    });
    return expect(element.type()).toBe('ResizableElement');
  });
});

describe('ContentEdit.ResizableElement.mount()', function() {
  var element, region;
  element = null;
  region = null;
  beforeEach(function() {
    element = new ContentEdit.ResizableElement('div', {
      'height': 200,
      'width': 200
    });
    region = new ContentEdit.Region(document.createElement('div'));
    region.attach(element);
    return element.unmount();
  });
  it('should mount the element to the DOM and set the size attribute', function() {
    var size;
    element.mount();
    expect(element.isMounted()).toBe(true);
    size = element.domElement().getAttribute('data-ce-size');
    return expect(size).toBe('w 200 × h 200');
  });
  return it('should trigger the `mount` event against the root', function() {
    var foo, root;
    foo = {
      handleFoo: function() {}
    };
    spyOn(foo, 'handleFoo');
    root = ContentEdit.Root.get();
    root.bind('mount', foo.handleFoo);
    element.mount();
    return expect(foo.handleFoo).toHaveBeenCalledWith(element);
  });
});

describe('ContentEdit.Element.resize()', function() {
  return it('should call `startResizing` against the root element', function() {
    var element, region, root;
    element = new ContentEdit.ResizableElement('div', {
      'height': 200,
      'width': 200
    });
    region = new ContentEdit.Region(document.createElement('div'));
    region.attach(element);
    root = ContentEdit.Root.get();
    spyOn(root, 'startResizing');
    element.resize(['top', 'left'], 0, 0);
    return expect(root.startResizing).toHaveBeenCalledWith(element, ['top', 'left'], 0, 0, true);
  });
});

describe('ContentEdit.Element.size()', function() {
  return it('should set/get the size of the element', function() {
    var element;
    element = new ContentEdit.ResizableElement('div', {
      'height': 200,
      'width': 200
    });
    expect(element.size()).toEqual([200, 200]);
    element.size([100, 100]);
    return expect(element.size()).toEqual([100, 100]);
  });
});
